name: BTC Sentiment Pipeline

on:
  # Run on schedule (every hour)
  schedule:
    - cron: '0 * * * *'  # Every hour at minute 0
  
  # Allow manual triggering
  workflow_dispatch:
  
  # Run on push to main (optional - for testing)
  push:
    branches:
      - main
    paths:
      - 'src/pipelines/**'
      - '.github/workflows/pipeline.yml'

jobs:
  run-pipeline:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: write  # Allow creating releases and uploading artifacts
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Check disk space
        run: |
          df -h
          echo "Available disk space before installation"
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          # Install CPU-only PyTorch first (much smaller, ~200MB vs ~3GB)
          # This prevents running out of disk space on GitHub Actions
          pip install torch --index-url https://download.pytorch.org/whl/cpu
          # Install transformers (depends on torch)
          pip install transformers
          # Then install rest of requirements (excluding torch and transformers)
          pip install fastapi uvicorn streamlit sqlalchemy pandas pydantic-settings plotly requests pytest httpx python-json-logger feedparser schedule
          # Clean up pip cache to save space
          pip cache purge
      
      - name: Check disk space after installation
        run: |
          df -h
          echo "Available disk space after installation"
      
      - name: Create .env file
        run: |
          # Create .env from GitHub Secrets
          # Use secrets if available, otherwise use defaults
          cat > .env << EOF
          DB_URL=sqlite:///btc_sentiment.db
          NEWS_FEEDS=${{ secrets.NEWS_FEEDS }}
          REDDIT_FEEDS=${{ secrets.REDDIT_FEEDS }}
          COINGECKO_BASE=${{ secrets.COINGECKO_BASE }}
          ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}
          EOF
          # Replace empty values with defaults
          python3 << 'PYTHON'
          import os
          with open('.env', 'r') as f:
              content = f.read()
          # Set defaults for empty values
          lines = content.split('\n')
          result = []
          for line in lines:
              if line.startswith('NEWS_FEEDS=') and line == 'NEWS_FEEDS=':
                  result.append('NEWS_FEEDS=https://cointelegraph.com/rss')
              elif line.startswith('REDDIT_FEEDS=') and line == 'REDDIT_FEEDS=':
                  result.append('REDDIT_FEEDS=bitcoin')
              elif line.startswith('COINGECKO_BASE=') and line == 'COINGECKO_BASE=':
                  result.append('COINGECKO_BASE=https://api.coingecko.com/api/v3')
              elif line.startswith('ALLOWED_ORIGINS=') and line == 'ALLOWED_ORIGINS=':
                  result.append('ALLOWED_ORIGINS=http://localhost:8501,http://localhost:8000')
              else:
                  result.append(line)
          with open('.env', 'w') as f:
              f.write('\n'.join(result))
          print("Created .env file:")
          with open('.env', 'r') as f:
              print(f.read())
          PYTHON
      
      - name: Download database from latest release
        run: |
          echo "ðŸ” Checking for existing database releases..."
          
          # Get the most recent database release tag
          LATEST_TAG=$(gh release list --limit 100 --json tagName,createdAt \
            | jq -r '[.[] | select(.tagName | startswith("db-"))] | sort_by(.createdAt) | reverse | .[0].tagName' \
            | head -1)
          
          if [ ! -z "$LATEST_TAG" ] && [ "$LATEST_TAG" != "null" ]; then
            echo "ðŸ“¥ Found latest database release: $LATEST_TAG"
            echo "   Downloading database..."
            
            # Download the database file from the release
            gh release download "$LATEST_TAG" --pattern "btc_sentiment.db" --clobber || {
              echo "âš ï¸  Download failed, will start with fresh database"
              exit 0
            }
            
            if [ -f "btc_sentiment.db" ]; then
              echo "âœ… Database downloaded successfully"
              ls -lh btc_sentiment.db
              sqlite3 btc_sentiment.db "SELECT COUNT(*) as total_records FROM sentiment_indices;" || echo "   (Database stats unavailable)"
            fi
          else
            echo "â„¹ï¸  No previous database releases found"
            echo "   This is normal on first run - will create new database"
          fi
        env:
          GH_TOKEN: ${{ github.token }}
      
      - name: Run collection pipeline
        run: |
          python -m src.pipelines.collect
      
      - name: Run scoring pipeline
        run: |
          python -m src.pipelines.score
      
      - name: Run aggregation pipeline (hourly)
        run: |
          python -m src.pipelines.aggregate --granularity hourly --days 7
      
      - name: Run aggregation pipeline (daily)
        run: |
          python -m src.pipelines.aggregate --granularity daily --days 30
      
      - name: Cleanup old data (keep 60 days)
        run: |
          python -m src.pipelines.cleanup --retention-days 60
      
      - name: Upload to GitHub Release (for Render to download)
        if: success()
        run: |
          echo "ðŸ“¦ Preparing database release..."
          
          # Show database stats before upload
          if [ -f "btc_sentiment.db" ]; then
            echo "Database size: $(du -h btc_sentiment.db | cut -f1)"
            echo "Records by granularity:"
            sqlite3 btc_sentiment.db "SELECT granularity, COUNT(*) as count FROM sentiment_indices GROUP BY granularity;" || echo "  (Stats unavailable)"
          fi
          
          # Create a release tag with timestamp
          TAG_NAME="db-$(date +%Y%m%d-%H%M%S)"
          
          echo "ðŸš€ Creating release: $TAG_NAME"
          
          # Create release and upload database
          gh release create "$TAG_NAME" btc_sentiment.db \
            --title "Database Update $(date '+%Y-%m-%d %H:%M UTC')" \
            --notes "Automated database update from pipeline. Contains accumulated sentiment data." \
            --repo ${{ github.repository }}
          
          echo "âœ… Release created successfully"
          
          # Keep only the 3 most recent releases (cleanup old ones)
      
      - name: Summary
        run: |
          echo "âœ… Pipeline completed successfully"
          if [ -f "btc_sentiment.db" ]; then
            echo "ðŸ“¦ Database uploaded to GitHub Release"
            echo "ðŸŒ Render will download latest release on next deployment"
            echo ""
            echo "Database info:"
            ls -lh btc_sentiment.db
            echo ""
            echo "Next run will download this database and append new data"
          else
            echo "âš ï¸ No database file found"
          fi


